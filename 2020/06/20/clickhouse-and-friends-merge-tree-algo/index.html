
<!DOCTYPE html>
<html lang="zh">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="clickhouse,ClickHouse和他的朋友们,lsm,btree," />
  

  
    <meta name="description" content="ClickHouse和他的朋友们： 存储引擎技术进化与MergeTree" />
  
  
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <title>ClickHouse和他的朋友们： 存储引擎技术进化与MergeTree [ 虎哥的博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="虎哥的博客" type="application/atom+xml">
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/logo.png">
    <span class="title">虎哥的博客</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/atom.xml" class="pure-menu-link">订阅</a></li>
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        ClickHouse和他的朋友们： 存储引擎技术进化与MergeTree
      </h1>
      <span>
        
        <time class="time" datetime="2020-06-19T16:00:00.000Z">
        2020-06-20
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ClickHouse%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/" rel="tag">ClickHouse和他的朋友们</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/btree/" rel="tag">btree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clickhouse/" rel="tag">clickhouse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lsm/" rel="tag">lsm</a></li></ul>
      </span>
    </span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
    </header>

    <div class="post-content">
      <p>21世纪的第二个10年，虎哥已经在存储引擎一线奋战近10年，由于强大的兴趣驱动，这么多年来几乎不放过arXiv上与存储相关的每一篇paper。<br>尤其是看到带有draft的paper时，有一种乞丐听到“叮当”响时的愉悦。<br>看paper这玩意就像鉴宝，多数是“赝品”，需要你有“鉴真”的本领，否则今天是张三的算法超越了xx，明儿又是王二的硬件提升了yy，让你永远跟不上节奏zz，湮灭在这些没有营养的技术垃圾中，浪费大好青春。</p>
<p>言归正传，接下来的3篇，跟ClickHouse的MergeTree引擎有关：<br><b>上篇介绍存储引擎的技术演进史</b>，从”远古”的B-tree出发推演到目前主流的技术架构。<br><b>中篇会从源码层面介绍MergeTree内核原理</b>，对ClickHouse MergeTree代码进行打点跟踪调试，提供一个阅码导航。<br><b>下篇会从实战出发</b>，基于MergeTree机制，如何合理设计来进行科学加速。</p>
<p>本文为上篇，先来个热身，相信本篇大部分内容对大家来说都比较陌生，很少人写过。</p>
<h2 id="地位"><a href="#地位" class="headerlink" title="地位"></a><b>地位</b></h2><p>存储引擎(事务型)在一个数据库(DBMS)中的地位如何呢？</p>
<p>MySQL的商业成功可以说大部分来自于InnoDB引擎，Oracle收购InnoDB比MySQL早好几年呢！<br>20年前，能亲手撸一套<a href="https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics" target="_blank" rel="noopener">AIRES(Algorithms for Recovery and Isolation Exploiting Semantics)</a>规范引擎，实力还是相当震撼的，相信Oracle收购的不仅是InnoDB这个引擎，更重要的是人，InnoDB作者在哪里，在干什么？！<br>Fork出来的MariaDB这么多年一直找不到自己的灵魂，在Server层磨磨蹭蹭可谓是江河日下，只能四处收购碰碰运气，当年TokuDB战斗过的commit依在，但这些已经是历史了。<br>另，WiredTiger被MongoDB收购并使用，对整个生态所起的作用也是无可估量的，这些发动机引擎对于一辆汽车是非常重要的。</p>
<p>有人问道，都已经2020年了，开发一个存储引擎还这么难吗？不难，但是造出来的未必有RocksDB好用？！<br>如大家所见，很多的分布式存储引擎都是基于RocksDB研发，可谓短期内还算明智的选择。<br>从工程角度来看，一个ACID引擎要打磨的东西非常之多，到处充斥着人力、钱力、耐心的消耗，一种可能是写到一半就停滞了(如<a href="https://github.com/BohuTANG/nessDB" target="_blank" rel="noopener">nessDB</a>)，还有一种可能是写着写着发现跟xx很像，沃茨法克。<br>当然，这里并不是鼓励大家都去基于RocksDB去构建自己的产品，而是要根据自己的情况去做选择。</p>
<h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a><b>B-tree</b></h2><p>首先要尊称一声大爷，这个大爷年方50，目前支撑着数据库产业的半壁江山。</p>
<p>50年来不变而且人们还没有改变它的意向，这个大爷厉害的很！<br>鉴定一个算法的优劣，有一个学派叫<b>IO复杂度分析</b>，简单推演真假便知。<br>下面就用此法分析下B-tree(traditional b-tree)的IO复杂度，对读、写IO一目了然，真正明白读为什么快，写为什么慢，如何优化。<br>为了可以愉快的阅读，本文不会做任何公式推导，复杂度分析怎么可能没有公式呢！</p>
<h3 id="读IO分析"><a href="#读IO分析" class="headerlink" title="读IO分析"></a><b>读IO分析</b></h3><p>这里有一个3-level的B-tree，每个方块代表一个页，数字代表page ID。</p>
<img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/btree-read.png" align="center" style="zoom:40%;" />

<p>上图B-tree结构是<b>内存</b>的一个表现形式，如果我们要读取的记录在leaf-8上，read-path如蓝色箭头所示:<br>root-9 –&gt; branch-6 –&gt; leaf-8</p>
<p>下图是B-tree在<b>磁盘</b>上的存储形式，meta page是起点:<br><img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/btree-read-disk.png" align="center" style="zoom:40%;" /></p>
<p>这样读取的随机IO(假设内存里没有page缓存且page存储是随机的)总数就是(蓝色箭头):</p>
<p>1(meta-10)IO +  1(root-9)IO + 1(branch-6)IO + 1(leaf-8)IO = 4次IO，这里忽略一直缓存的meta和root，就是<b>2</b>次随机IO。<br>如果磁盘seek是1ms，读取延迟就是<b>2ms</b>。</p>
<p>通过推演就会发现，B-tree是一种读优化(Read-Optimized)的数据结构，无论LSM-tree还是Fractal-tree等在读上只能比它慢，因为读放大(Read Amplification)问题。<br>存储引擎算法可谓日新月异，但是大部分都是在跟写优化(Write-Optimized)做斗争，那怕是一个常数项的优化那就是突破，自从Fractal-tree突破后再无来者了！</p>
<h3 id="写IO分析"><a href="#写IO分析" class="headerlink" title="写IO分析"></a><b>写IO分析</b></h3><p>现在写一条记录到leaf-8。</p>
<img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/btree-update-raw.png" align="center" style="zoom:40%;" />

<p>可以发现，每次写都需要先读取一遍，如上图蓝色路径所示。</p>
<p>假设这次写入导致root, branch都发生了变化，这种in-place的更新反映到磁盘上就是：</p>
<img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/btree-update-raw-disk.png" align="center" style="zoom:40%;" />

<p>基本是<b>2</b>次读IO和写<b>2</b>次写IO+WAL fsync，粗略为<b>4</b>次随机IO。<br>通过分析发现，B-tree对写操作不太友好，随机IO次数较多，而且in-place更新必须增加一个page级的WAL保证失败回滚，简直是要命。</p>
<h3 id="Write-Optimized-B-tree"><a href="#Write-Optimized-B-tree" class="headerlink" title="Write-Optimized B-tree"></a><b>Write-Optimized B-tree</b></h3><p>说到写优化，在机械盘的年代，大家的方向基本是把随机IO转换为顺序IO，充分发挥磁盘的机械优势，于是出现一种Append-only B-tree：<br><img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/btree-aof.png" align="center" style="zoom:40%;" /></p>
<ol>
<li>更新生成新的page(蓝色)</li>
<li>page回写磁盘时append only到文件末尾</li>
<li>无需page WAL，数据不overwrite，有写放大(Write Amplification)问题，需要做空洞重利用机制</li>
</ol>
<p>Append-only B-tree节省了回写时的2次随机IO，转换为常数级(constant)的1次顺序IO，写性能大幅提升，总结起来就是：<br><b>随机变顺序，空间换时间</b><br>LSM-tree, Fractal-tree等写优化算法的核心思想也是这个，只不过其实现机制不同。</p>
<h2 id="LSM-trees"><a href="#LSM-trees" class="headerlink" title="LSM-trees"></a><b>LSM-trees</b></h2><p>随着LevelDB的问世，LSM-tree逐渐被大家所熟知。<br>LSM-Tree更像一种思想，模糊了B-tree里tree的严肃性，通过文件组织成一个更加松散的tree。<br>这里不谈一个具体的LSM-Tree是Leveled还是Size-tiered，只谈大体思想。</p>
<img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/lsm-tree.png" align="center" style="zoom:40%;" />

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a><b>写入</b></h3><ol>
<li><p>先写入内存的C0</p>
</li>
<li><p>后台线程根据规则(Leveled/Sized)进行merge，C0 –&gt; C1, C1 –&gt; C2 … CL</p>
</li>
<li><p>写入C0即可返回，IO放到后台的Merge过程</p>
</li>
<li><p>每次Merge是硬伤，动作大就抖，动作小性能不好，每次Merge的数据流向不明确</p>
</li>
<li><p>写放大问题</p>
</li>
</ol>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a><b>读取</b></h3><ol>
<li>读取C0</li>
<li>读取C1 .. CL</li>
<li>合并记录返回</li>
<li>读放大问题</li>
</ol>
<h2 id="Fractal-tree"><a href="#Fractal-tree" class="headerlink" title="Fractal-tree"></a><b>Fractal-tree</b></h2><p>终于发展到了“终极”优化(目前最先进的索引算法)，Fractal-tree。<br>它是在Append-only B-tree的基础上，对每个branch节点增加了一个message buffer作为缓冲，可以看做是LSM-tree 和 Append-only B-tree完美合体。</p>
<p>相对于LSM-tree它的优势非常明显:<br>Merge更加有序，数据流向非常分明，消除了Merge的抖动问题</p>
<p>这个高科技目前只有<a href="https://github.com/xelabs/tokudb" target="_blank" rel="noopener">TokuDB</a>在使用，这个算法可以开篇新介，这里不做累述，感兴趣的可以参考原型实现<a href="https://github.com/BohuTANG/nessDB" target="_blank" rel="noopener">nessDB</a>。</p>
<h2 id="Cache-oblivious"><a href="#Cache-oblivious" class="headerlink" title="Cache-oblivious"></a><b>Cache-oblivious</b></h2><p>这个词对于大部分人都是陌生的，不过别怕。<br>在存储引擎里，有一个数据结构非常非常重要，它负责page数据有序性维护，比如在一个page里怎么快速定位到我要的记录。<br>在LevelDB里使用Skiplist，但大部分引擎使用的是一个有序数组来表示，比如[1, 2, 3, … 100]，然后使用二分查找。</p>
<p>大概10年前一位内核开发者发表了一篇&lt;<a href="https://queue.acm.org/detail.cfm?id=1814327" target="_blank" rel="noopener">You’re Doing It Wrong</a>&gt;，这个小文讲了一个很有意思的事情:<br>数据的组织形式对性能有很大的影响，因为CPU有cache line。</p>
<p>抛开这篇文章不谈，咱们来看一张“神仙”图：</p>
<img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/veb-layout.png" align="center" style="zoom:40%;" />

<p>这是一个binary tree的4种layout表示形式，那么哪种layout对CPU cache line最友好？</p>
<p>也许你已经猜对了，那就是van Emde Boas，简称vEB。<br>因为它的相邻数据“扎堆”存储，point-query和range-query的cache line可以最大化共享，Skiplist对cache line是非常不友好的。<br>对于Cache oblivious数据结构，这里有一个简单的原型实现: <a href="https://github.com/BohuTANG/omt" target="_blank" rel="noopener">omt</a></p>
<h2 id="B-tree优化魔力象限"><a href="#B-tree优化魔力象限" class="headerlink" title="B-tree优化魔力象限"></a><b>B-tree优化魔力象限</b></h2><p>写优化算法从原生的B-tree到Append-only B-tree(代表作LMDB)，又到LSM-tree(LevelDB/RocksDB等)，最后进化到目前最先进的Fractal-tree(TokuDB)。<br>这些算法耗费了很多年才在工程上实现并被认可，研发一款存储引擎缺的不是算法而是“鉴宝”的能力，这个“宝”可能已经躺了几十年了。</p>
<p>其实，”科学家”们已经总结出一个B-tree优化魔力象限:</p>
<img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/btree-optimal-curve.png" align="center" style="zoom:50%;" />

<p>横坐标是写性能，纵坐标是读性能，B-tree和Logging数据结构分布在曲线的两个极端。<br>B-tree的读性能非常好，但是写性能差。<br>Logging的写性能非常好，但是读性能差(想想我们每次写都把数据追加到文件末尾，是不是很快？但是读…)。</p>
<p>在它们中间有一个优化曲度(Optimal Curve)。<br>在这个曲度上，你可以通过增加/减少一个常数(1-epsilon)来做读和写优化组合，LSM-tree/Fractal-tree都在这个曲度之上。  </p>
<img src="https://bohutang-1253727613.cos.ap-beijing.myqcloud.com/posts/btree-epsilon.png" align="center" style="zoom:20%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><b>总结</b></h2><p>本文主要讨论事务性引擎的技术演进，其中包含了IO复杂度分析，其实这个分析是基于一个DAM( Disk Access Machine)模型，这里不再展开。<br>这个模型要解决什么问题呢？<br>如果工程中涉及硬件层级关系，比如Disk/Memory/CPU，数据在Disk，读取(以block为单位)到Memory，查找计算(cache-line)在CPU，<br>不同介质间性能差距又非常之大，我们怎么做才能让整体性能更优的问题。<br>和当今的硬件相融合，这个模型也一样适用。</p>
<p>最后回到ClickHouse的MergeTree引擎，它只使用了本文中的部分优化，实现也比较简洁、高效，毕竟没有事务，撸起来也没啥心理负担。<br><strong>随机变顺序，空间换时间</strong>， MergeTree原理，请听下回分解。</p>
<h2 id="References"><a href="#References" class="headerlink" title=" References"></a><b> References</b></h2><p>[1] <a href="https://www.cs.au.dk/~gerth/papers/cacheoblivious05.pdf" target="_blank" rel="noopener">Cache-Oblivious Data Structures</a><br>[2] <a href="https://www3.cs.stonybrook.edu/~bender/talks/2013-BenderKuszmaul-xldb-tutorial.pdf" target="_blank" rel="noopener">Data Structures and Algorithms for Big Databases</a><br>[3] <a href="https://link.springer.com/chapter/10.1007%2F3-540-60220-8_74" target="_blank" rel="noopener">The buffer tree: A new technique for optimal I/O-algorithms</a><br>[4] <a href="http://www.bzero.se/ldapd/btree.html" target="_blank" rel="noopener">how the append-only btree works</a><br>[5] <a href="https://www.douban.com/note/269741273/" target="_blank" rel="noopener">写优化的数据结构(1):AOF和b-tree之间</a><br>[6] <a href="https://www.douban.com/note/269744617/" target="_blank" rel="noopener">写优化的数据结构(2):buffered tree</a><br>[7] <a href="https://www.douban.com/note/304123656/" target="_blank" rel="noopener">存储引擎数据结构优化(1):cpu bound</a><br>[8] <a href="https://www.douban.com/note/304349195/" target="_blank" rel="noopener">存储引擎数据结构优化(2):io bound</a><br>[9] <a href="https://github.com/BohuTANG/nessDB" target="_blank" rel="noopener">nessDB</a><br>[10] <a href="https://github.com/BohuTANG/omt" target="_blank" rel="noopener">omt</a></p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#地位"><span class="toc-text">地位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-tree"><span class="toc-text">B-tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读IO分析"><span class="toc-text">读IO分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写IO分析"><span class="toc-text">写IO分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-Optimized-B-tree"><span class="toc-text">Write-Optimized B-tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LSM-trees"><span class="toc-text">LSM-trees</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#写入"><span class="toc-text">写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取"><span class="toc-text">读取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fractal-tree"><span class="toc-text">Fractal-tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-oblivious"><span class="toc-text">Cache-oblivious</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-tree优化魔力象限"><span class="toc-text">B-tree优化魔力象限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-text"> References</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share" style="width: 100%;">

<div class="share" style="width: 100%;">
</div>
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/06/11/clickhouse-and-friends-processor/" rel="next" title="ClickHouse和他的朋友们： Pipeline处理器和调度器">
          ClickHouse和他的朋友们： Pipeline处理器和调度器
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
      </div>
    </div>
  

    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://bohutang.me">首页</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>

  
  <!-- scripts list from theme config.yml -->
  
    <script src="//cdn.bootcss.com/zepto/1.2.0/zepto.min.js"></script>
  


<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
